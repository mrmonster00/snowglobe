<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Snowglobe</title>

  <!-- iOS “app-like” full screen when added to Home Screen -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; touch-action:manipulation; }

    .hint {
      position:fixed; left:12px; bottom:12px; right:12px;
      color:#fff; font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      opacity:.9;
      background:rgba(0,0,0,.35); padding:10px 12px; border-radius:12px;
      backdrop-filter: blur(6px);
    }
    .btn {
      position:fixed; top:12px; right:12px;
      color:#fff; font:14px system-ui; background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.25); padding:10px 12px; border-radius:12px;
    }
    .toggle {
      position:fixed; top:12px; left:12px;
      color:#fff; font:14px system-ui; background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.25); padding:10px 12px; border-radius:12px;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <button class="toggle" id="fitToggle">Fit: CONTAIN</button>
  <button class="btn" id="enableMotion">Enable Shake</button>
  <div class="hint" id="hint">Tap to shake ❄️ (On iPhone, press <b>Enable Shake</b> once.)</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  const hint = document.getElementById("hint");
  const btn = document.getElementById("enableMotion");
  const fitToggle = document.getElementById("fitToggle");

  // Put photo.png in the same GitHub repo folder as this index.html
  const img = new Image();
  img.src = "photo.png";

  // === IMAGE FIT MODE ===
  // "contain" = no crop (may have bars)
  // "cover"   = fill screen (crops)
  let FIT_MODE = "contain";
  function updateFitLabel() {
    fitToggle.textContent = "Fit: " + (FIT_MODE === "contain" ? "CONTAIN" : "COVER");
  }
  fitToggle.addEventListener("click", () => {
    FIT_MODE = (FIT_MODE === "contain") ? "cover" : "contain";
    updateFitLabel();
  });
  updateFitLabel();

  // Snow particles
  const flakes = [];
  const MAX_FLAKES = 900;

  let width = 0, height = 0, dpr = 1;

  // Shake energy (tap or phone motion adds to it)
  let burst = 0;
  let wind = 0;
  const gravity = 0.55;

  function resize() {
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    width = Math.floor(window.innerWidth * dpr);
    height = Math.floor(window.innerHeight * dpr);
    canvas.width = width;
    canvas.height = height;
  }

  window.addEventListener("resize", resize);
  window.addEventListener("orientationchange", () => setTimeout(resize, 300));
  resize();

  function orientationHint() {
    if (window.innerHeight > window.innerWidth) {
      hint.innerHTML = "Tip: rotate to landscape for a wider view ❄️ (Tap or shake to make snow.)";
    } else {
      hint.innerHTML = "Tap to shake ❄️ (On iPhone, press <b>Enable Shake</b> once.)";
    }
  }
  window.addEventListener("resize", orientationHint);
  window.addEventListener("orientationchange", () => setTimeout(orientationHint, 300));
  orientationHint();

  function rand(min, max) { return Math.random() * (max - min) + min; }

  function addFlake(count, xCenter = width / 2, yStart = -20 * dpr) {
    for (let i = 0; i < count && flakes.length < MAX_FLAKES; i++) {
      const r = rand(1.2, 4.4) * dpr;
      flakes.push({
        x: xCenter + rand(-width * 0.45, width * 0.45),
        y: yStart + rand(-height * 0.25, 0),
        r,
        vy: rand(0.3, 1.2) * dpr,
        vx: rand(-0.35, 0.35) * dpr,
        wob: rand(0, Math.PI * 2),
        wobSpeed: rand(0.006, 0.02),
        opacity: rand(0.5, 0.95)
      });
    }
  }

  // Initial snow
  addFlake(280, width / 2, rand(0, height));

  function burstSnow(strength = 1) {
    burst = Math.min(2.0, burst + 0.55 * strength);
    wind += rand(-1.6, 1.6) * dpr * strength;
    addFlake(Math.floor(110 * strength), width / 2, -30 * dpr);
  }

  // Tap/click to burst
  function onTap(e) {
    const x = (e.touches ? e.touches[0].clientX : e.clientX) * dpr;
    burstSnow(1);
    addFlake(60, x, -30 * dpr);
  }
  canvas.addEventListener("click", onTap);
  canvas.addEventListener("touchstart", onTap, { passive: true });

  // Device motion (shake only)
  let lastShakeAt = 0;
  function handleMotion(ev) {
    const a = ev.accelerationIncludingGravity;
    if (!a) return;

    const ax = a.x || 0, ay = a.y || 0, az = a.z || 0;
    const mag = Math.sqrt(ax * ax + ay * ay + az * az);

    // typical gravity magnitude ~9.8; shaking spikes higher
    const intensity = Math.max(0, mag - 11);
    const now = performance.now();

    if (intensity > 2.2 && now - lastShakeAt > 180) {
      lastShakeAt = now;
      burstSnow(Math.min(1.8, intensity / 6));
    }
  }

  // iOS permission flow + Android support
  btn.addEventListener("click", async () => {
    try {
      if (typeof DeviceMotionEvent !== "undefined" &&
          typeof DeviceMotionEvent.requestPermission === "function") {
        const res = await DeviceMotionEvent.requestPermission();
        if (res !== "granted") throw new Error("Permission not granted");
      }
      window.addEventListener("devicemotion", handleMotion);
      btn.textContent = "Shake Enabled";
      btn.disabled = true;
    } catch (e) {
      btn.textContent = "Motion Blocked";
      console.warn(e);
      alert("Motion access was blocked. You can still tap the screen to shake the snow.");
    }
  });

  // ✅ Correct background fitting (no double-dpr)
  function drawBackground() {
    if (!img.complete || !img.naturalWidth) return;

    const iw = img.naturalWidth;
    const ih = img.naturalHeight;

    const sx = width / iw;
    const sy = height / ih;

    const scale = (FIT_MODE === "cover") ? Math.max(sx, sy) : Math.min(sx, sy);

    const dw = iw * scale;
    const dh = ih * scale;

    const dx = (width - dw) / 2;
    const dy = (height - dh) / 2;

    ctx.drawImage(img, dx, dy, dw, dh);

    // Optional subtle vignette
    const g = ctx.createRadialGradient(
      width / 2, height / 2, Math.min(width, height) * 0.18,
      width / 2, height / 2, Math.max(width, height) * 0.70
    );
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,0.30)");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, width, height);
  }

  function step() {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, width, height);

    drawBackground();

    // Decay burst & wind
    burst *= 0.93;
    wind *= 0.985;

    // Add a few flakes while burst is active
    if (burst > 0.05) addFlake(Math.floor(8 + 30 * burst), width / 2, -30 * dpr);

    // Update + draw flakes
    for (let i = flakes.length - 1; i >= 0; i--) {
      const f = flakes[i];

      f.wob += f.wobSpeed;
      const wobX = Math.sin(f.wob) * 0.55 * dpr;

      const fall = (gravity + f.vy) * (1 + burst * 1.25);
      f.y += fall;
      f.x += (f.vx + wind * 0.02) + wobX;

      if (f.y - f.r > height) {
        f.y = -rand(10, 140) * dpr;
        f.x = rand(0, width);
      }
      if (f.x < -50 * dpr) f.x = width + 50 * dpr;
      if (f.x > width + 50 * dpr) f.x = -50 * dpr;

      ctx.beginPath();
      ctx.arc(f.x, f.y, f.r, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255,255,255,${f.opacity})`;
      ctx.fill();
    }

    requestAnimationFrame(step);
  }

  img.onload = () => requestAnimationFrame(step);
  img.onerror = () => {
    alert("Could not load photo.png. Make sure photo.png is in the same folder as index.html in your GitHub repo.");
    requestAnimationFrame(step);
  };
})();
</script>
</body>
</html>
