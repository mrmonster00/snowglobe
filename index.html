<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- Allow pinch zoom -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, user-scalable=yes, viewport-fit=cover" />
  <title>Snowglobe</title>

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <style>
    html, body { margin:0; height:100%; background:#000; }
    /* DO NOT block pinch zoom */
    canvas { display:block; width:100vw; height:100vh; touch-action:auto; }

    .hint {
      position:fixed; left:12px; right:12px; bottom:12px;
      color:#fff; font:14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:rgba(0,0,0,.35); padding:10px 12px; border-radius:12px;
      backdrop-filter: blur(6px);
    }
    .btn {
      position:fixed; top:12px; right:12px;
      color:#fff; font:14px system-ui; background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.25); padding:10px 12px; border-radius:12px;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <button class="btn" id="enableMotion">Enable Shake</button>
  <div class="hint" id="hint">Image is always “contain” (no crop). Rotate phone to resize. Pinch-zoom works. Tap to burst snow ❄️</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  const hint = document.getElementById("hint");
  const btn = document.getElementById("enableMotion");

  // Put photo.png in the same GitHub repo folder as index.html
  const img = new Image();
  img.src = "photo.png";

  // Canvas sizing (use visualViewport for iOS correctness)
  let width = 0, height = 0, dpr = 1;

  function getViewportSizeCSS() {
    // CSS pixels
    const vv = window.visualViewport;
    if (vv) return { w: vv.width, h: vv.height };
    return { w: window.innerWidth, h: window.innerHeight };
  }

  function resize() {
    const { w, h } = getViewportSizeCSS();

    // Limit DPR to keep it smooth
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    width  = Math.floor(w * dpr);
    height = Math.floor(h * dpr);

    canvas.width = width;
    canvas.height = height;
  }

  // iOS sometimes fires these in odd order—listen to all
  window.addEventListener("resize", () => {
    resize();
    // extra passes help on iOS rotate
    setTimeout(resize, 150);
    requestAnimationFrame(resize);
  });

  window.addEventListener("orientationchange", () => {
    // iOS needs a delay after rotation to settle viewport
    setTimeout(resize, 300);
    setTimeout(resize, 650);
  });

  if (window.visualViewport) {
    window.visualViewport.addEventListener("resize", () => {
      resize();
      requestAnimationFrame(resize);
    });
    window.visualViewport.addEventListener("scroll", () => {
      // sometimes affects reported viewport after pinch-zoom
      resize();
    });
  }

  resize();

  // ===== Snow =====
  const flakes = [];
  const MAX_FLAKES = 800;
  let burst = 0;

  function rand(min, max) { return Math.random() * (max - min) + min; }

  function addFlake(count, xCenter = width/2, yStart = -20*dpr) {
    for (let i=0; i<count && flakes.length < MAX_FLAKES; i++) {
      const r = rand(1.1, 4.0) * dpr;
      flakes.push({
        x: xCenter + rand(-width*0.45, width*0.45),
        y: yStart + rand(-height*0.25, 0),
        r,
        vx: rand(-0.25, 0.25) * dpr,
        vy: rand(0.25, 1.1) * dpr,
        wob: rand(0, Math.PI*2),
        wobSpeed: rand(0.006, 0.02),
        opacity: rand(0.5, 0.95),
      });
    }
  }

  addFlake(260, width/2, rand(0, height));

  function burstSnow(strength = 1) {
    burst = Math.min(2.0, burst + 0.6 * strength);
    addFlake(Math.floor(100 * strength), width/2, -30*dpr);
  }

  canvas.addEventListener("click", (e) => {
    burstSnow(1);
    addFlake(60, (e.clientX||0) * dpr, -30*dpr);
  });

  canvas.addEventListener("touchstart", (e) => {
    // still allow pinch zoom; this just adds a burst on first touch
    const t = e.touches && e.touches[0];
    if (t) {
      burstSnow(1);
      addFlake(60, t.clientX * dpr, -30*dpr);
    }
  }, { passive:true });

  // Shake (optional)
  let lastShakeAt = 0;
  function handleMotion(ev) {
    const a = ev.accelerationIncludingGravity;
    if (!a) return;
    const ax = a.x||0, ay=a.y||0, az=a.z||0;
    const mag = Math.sqrt(ax*ax + ay*ay + az*az);
    const intensity = Math.max(0, mag - 11);
    const now = performance.now();
    if (intensity > 2.2 && now - lastShakeAt > 180) {
      lastShakeAt = now;
      burstSnow(Math.min(1.8, intensity/6));
    }
  }

  btn.addEventListener("click", async () => {
    try {
      if (typeof DeviceMotionEvent !== "undefined" &&
          typeof DeviceMotionEvent.requestPermission === "function") {
        const res = await DeviceMotionEvent.requestPermission();
        if (res !== "granted") throw new Error("Permission not granted");
      }
      window.addEventListener("devicemotion", handleMotion, true);
      btn.textContent = "Shake Enabled";
      btn.disabled = true;
    } catch (e) {
      btn.textContent = "Motion Blocked";
      alert("Motion access blocked. Tap still works.");
    }
  });

  // ===== Background: ALWAYS CONTAIN (no crop) =====
  function drawBackgroundContain() {
    if (!img.complete || !img.naturalWidth) return;

    const iw = img.naturalWidth;
    const ih = img.naturalHeight;

    // NOTE: width/height are canvas pixels; iw/ih are image pixels
    const sx = width / iw;
    const sy = height / ih;
    const scale = Math.min(sx, sy); // <-- CONTAIN always

    const dw = iw * scale;
    const dh = ih * scale;

    const dx = (width  - dw) / 2;
    const dy = (height - dh) / 2;

    ctx.drawImage(img, dx, dy, dw, dh);
  }

  function step() {
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,width,height);

    drawBackgroundContain();

    burst *= 0.93;
    if (burst > 0.05) addFlake(Math.floor(6 + 22 * burst), width/2, -30*dpr);

    for (let i=flakes.length-1; i>=0; i--) {
      const f = flakes[i];
      f.wob += f.wobSpeed;

      const wobX = Math.sin(f.wob) * 0.55 * dpr;
      f.y += f.vy * (1 + burst*0.8);
      f.x += f.vx + wobX;

      if (f.y - f.r > height) {
        f.y = -rand(10, 120) * dpr;
        f.x = rand(0, width);
      }
      if (f.x < -50*dpr) f.x = width + 50*dpr;
      if (f.x > width + 50*dpr) f.x = -50*dpr;

      ctx.beginPath();
      ctx.arc(f.x, f.y, f.r, 0, Math.PI*2);
      ctx.fillStyle = `rgba(255,255,255,${f.opacity})`;
      ctx.fill();
    }

    requestAnimationFrame(step);
  }

  img.onload = () => requestAnimationFrame(step);
  img.onerror = () => alert("Could not load photo.png. Make sure it’s in the same repo folder as index.html.");
})();
</script>
</body>
</html>
